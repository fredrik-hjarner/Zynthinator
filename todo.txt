* deleteAllNodesReducer blev
  revertToInitialStateReducer.

* implement UNDO.

* Init <selects> in ConnectNodesButton.jsx (and other buttons as well).

* I have no VALIDATION on my MODALS.

* getConnectionsInReadableFormat
    should be split up.
    getConnectionInReadableFormat should do it,
    then getConnectionsInReadableFormat just calls that one.

* Should not be able to connect a node to itself !!!

* All MODELs should have it's outputs and inputs as getters on them!
    Makes it more dynamic!
    For example the PHASE of the OSCILLATOR can become an input!!

* probably remove the "nodeManagement" from state.

* Bug when minimizing Visualizers.

* TODO:
    - One should be able to disable some top-right icons in SimpleWindow.

* Allow the deepFreezing to be enabled and disabled in a DEBUG file.

* Upload the files to fredrikhjarner.se
    automatically on 'npm run build'
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

* [
    {
      action,
      timestamp,
    }
  ]
  rename timestamp to deltaTime.

* Frekvensen av LowResolutionSine
    kan göras modifierbar i real-time
    mha. en sawTooth och en Delay.

* Gör fler semantic++ komponenter.
  - T ex en select ska inte synas om den inte har några options.

* Implementera "Spectogram".

* Byt ut alla
  handleX()
  mot
  onX()

* När jag tar bort en node, så ska också de grupper den ingår i tas bort.

* Efter en memoized reselect så ska det inte finnas någon .map
    osv, för då är memoizeringen onödig eftersom det skapas
    nya object hela tiden ändå.

* FrequencyDomainVisualizersRedux shit:
    node.webAudioNode = nodeModels.nodes[node.id]; // todo there is no guarantee that the node exists yet!!!

    Lös detta genom att ha en state.webAudioNodes
    som håller koll på vilka webAudioNodes som skapats
    När en webAudioNodes skapas så ska den dispatcha en action!!!!!!

* CreateConnectionsRedux 
  & CreateGroupRedux
  & FrequencyDomainVisualizersRedux
  & TimeDomainVisualizersRedux
    are unoptimized because it does map after memoizedStateQueries.

* Viss kod anropar .webAudioNode direkt, vilket suger eftersom den inte
    ska kallas på direkt.

* "inputs"
    till noder kanske ska kunna ha typer.
    de vanligaste är float
    men t ex en "play" input ska kunna vara BOOLEAN.

* Edit Knob.

* highestNodeIdYet: 1,
    highestConnectionIdYet: 0,
    highestGroupIdYet: 0,
    highestKnobIdYet: 1,
    highestTriggerIdYet: 0,

    looks like shit.
    Should be only one: 'highestIdYet'

* AudioSystem borde vara uppdelat i delar som var för sig lyssnar
    på den del av state som de är intresserade av.
    Delarna ska vara t ex:
      - nodes
      - connections
      - triggeredTriggers
      - knobs?

* DeleteTriggerRedux &
  DeleteKnobRedux
  är identiska.

* One should be able to disable/enable removing duplicates/unnecessary
    stuff from the action history file.

* History (and history files) should be dynamically compressed.

* the knobs don't get their position from state
    which could be a problem for example when saving and
    loading history, the knobs will always show 0 (zero).

* The history should be able to be filtered as it is added to
    the state. Now only the downloaded file is filtered.

* this.timeDomainCanvasId
    should be
    this.state.timeDomainCanvasId

* bitsToRecord is a bad name. it's not bits.

* Minimizing oscillator stops all visualization and can't be resumed... :/

* audioSystem is running at Splash Screen, it should not!
  - should perhaps be it's own separate page
      i.e. outside of a Single-page App.

* When it crashes I should have the ability to download the ACTION HISTORY.

* When I replay a history I should be able to manually go forward
    action by action!

* The name prop, does not make any sense
    for many-to-one connections
    since it creates several connections.

* The "multiple selection dropdowns"
    should have their "value prop" set
    and now it is not.

* For better testing:
    Record a session. Record all the actions and the state afterwards.
    After refactorings, play the session and see if the actions
      produce exact the same outputs :)

* _updateScaleAndOffset
    can probably be refactored into some Util.js.

* Example 2 is not working.
    Only works when I refresh the page does it start to work.
    What the fuck is wrong?

* Refactoring possibility.
    I might split all the inputs up!
    So that I have a
      - SelectNodeInput
      - SelectNodeWithInputsInput
      - SelectConnectionInput
      - etc.

* Use redux-forms! Maybe...

* Top menu is not wholly visible on low-res.
    Do something with menu in low-res.

* Layout is not a fucking reusable component,
    so it should not be under /components.

* Home is a really bad name for the route.

* ESLint should force me to make PropTypes!

* getConnectionInReadableFormat is right generates "semantic options"
    which is not ideal, and not as reusble.

* // wtf is this function?!
  getNodeByIdInReadableFormat =
    R.compose(
      this.getNodeInReadableFormat,
      R.flip(R.prop)
    )

* Don't use lodash, use lodash/fp.

* Add pink noise. rename noise to white noise.

* All nodes should have a gain!!!!

* Implement Redux Ducks.

* Web Audio API square waves look like crap!!!!!!!!1
    So make my own one with audiobuffer or Triangle + WaveShaper

* Inspired by Falstad:
    Nested examples menu showing how different nodees work etc.

* "bounds" for parameters in nodeTypeDefinitons.js
    i.e max and min values so the user doesn't fuck up.

* Have an option for each node (or node param) in nodeTypeDefinitons
    that indicates whether the whole Node should be recreated
    upon a change in value of a parameter.

    It is the easiest way to change the value of a parameter,
      simply recreate the Node with the updated parameter value!

* When an Analyser is created a UI component is added to the state.
   THAT SUCKS!
    I should be like this:
      1. An Analyser is added to the state
      2. Something listens to Analysers and if one has been added,
      3. then add a UI component to the state.
      4. Then the UI listens to that state and draws it.

* Disable/enable connections.
    By clicking an arrow symbol in a displayed connection
    I toggle enabled/disabled, so I can test to connect/disconnect
    parts of the tree on the fly in real-time.

* ConnectionArrow component should get the connection or
    connectionId as a prop.
    Should be possible to trigger a disableConnection(id)
    action by clicking on a ConnectionArrow.

* Create a CrashModal that shows
    at window.onerror
    and allows to
      - save history
      - reset localStorage

* Don't always split up into Dumb, Smart and Redux Components.
    Only do so if a file exceeds 100 lines of code.

* Every example should make a Modal pop up with information
    about the example.

* When creating example I need functionality to clean up all
    extra fluff in the action history.

* When a node is displayed in an form-input, it should
    get the color from the node-type just as when 
    nodes are displayed in node-tree.

* Eject node problems:
    Now I can only choose the node and not the specific
    connection, which means that the node is ejected
    from ALL connections.

* Model:s built-in gain-nodes have a problem:
    When I connect a node that the gain-node,
    a gain of 1 is added to the input,
    but the gain should really be zero + input.

* As I did with 'addGain' I should make a 'addChangeRange'.

* AudioBufferSourceNode has a
    'playbackRate' prop
    make use of it.

* Bug where "knobbing" playbackRate adds to 1
    Should add with zero when a knob is connected.

* I can do 'quantization' with AudioWorklets!!

* I can do what I am doing in ChangeRange and have
    - defaults
    - params
    - willConnectToMe
    - willDisconnectToMe
  and use that for ALL nodes i.e. generalize.

* Dont use CDN:s because they can go down.
    for jQuery.

* All actions should have uuid:s so it is easier to
    find a specific action in history.

* use 'safeDisconnect' everywhere.

* Remake ADSR so that 'play' is triggered on rising edge
    and 'stop' on falling edge.

* create a Schmitt Trigger.

* PWM glitches because ChangeRange glitches.
